{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/29/hello-world/"},{"title":"vscode &amp; wsl2 实现c&#x2F;cpp的多文件编译调试","text":"本篇文章将介绍wsl2环境下 vscode的多文件编译 vscode和wsl2的安装与下载就不再过多的赘述 step1: 安装vscode插件 12C/C++ Extension Packcmake step2：在linux安装cmake， make 使用cmake是因为cmake对于多文件编译比较方便 debian系linux可以使用以下命令一键安装 1sudo apt install cmake make gcc g++ gbd 在这里，环境方面就准备的差不多了 接下来配置vscode中最令人头疼的tasks.json 与 launch.json 调试时，在当前文件所在的目录下新建一个bulid文件，以免生成过多的cmake的文件 tasks.json 1234567891011121314151617181920212223242526272829303132333435{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;options&quot;: { &quot;cwd&quot;: &quot;${fileDirname}/build&quot; }, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;cmake&quot;, &quot;command&quot;: &quot;cmake&quot;, &quot;args&quot;: [ &quot;..&quot; ] }, { &quot;label&quot;: &quot;make&quot;, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }, &quot;command&quot;: &quot;make&quot;, &quot;args&quot;: [] }, { &quot;label&quot;: &quot;Build&quot;, &quot;dependsOrder&quot;: &quot;sequence&quot;, &quot;dependsOn&quot;: [ &quot;cmake&quot;, &quot;make&quot; ] } ],} launch.json 123456789101112131415161718192021222324252627282930313233343536{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) hqyj&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/bulid/${fileBasenameNoExtension}&quot;, // 这里是可执行文件路径，可以根据自己的需求更改 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;/usr/bin&quot;, &quot;environment&quot;:[], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;Build&quot; } ]} 配置完成后，就可以开始愉快的编码啦","link":"/2023/07/03/vscode-wsl2-%E5%AE%9E%E7%8E%B0c-cpp%E7%9A%84%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/"},{"title":"nvim快捷键备忘","text":"return { – The default ‘‘ is the space. leader = “ “, -- 键切换/跳转窗口 jump_left_window = &quot;&lt;C-h&gt;&quot;, jump_right_window = &quot;&lt;C-l&gt;&quot;, jump_up_window = &quot;&lt;C-k&gt;&quot;, jump_down_window = &quot;&lt;C-j&gt;&quot;, -- View other usage of the plugin: https://github.com/akinsho/bufferline.nvim -- 选择缓冲区选项卡 pick_tab = &quot;&lt;leader&gt;b&quot;, -- View other usage of the plugin: https://github.com/nvim-neo-tree/neo-tree.nvim -- 打开或关闭文件资源管理器。 file_explorer = &quot;&lt;F9&gt;&quot;, -- 打开或关闭浮动窗口上的git status。 git_status = &quot;&lt;F8&gt;&quot;, -- View other usage of the plugin: https://github.com/stevearc/aerial.nvim -- 打开或关闭大纲，它需要调用lsp服务器 outline = &quot;&lt;F7&gt;&quot;, -- View other usage of the plugin: https://github.com/akinsho/toggleterm.nvim -- 打开或关闭终端 terminal_float = &quot;&lt;A-u&gt;&quot;, -- open terminal in a float window terminal_bottom = &quot;&lt;A-b&gt;&quot;, -- open terminal at the bottom -- View other usage of the plugin: https://github.com/Shatur/neovim-session-manager -- 切换会话 switch_session = &quot;&lt;leader&gt;ss&quot;, -- View other usage of the plugin: https://github.com/nvim-telescope/telescope.nvim -- 查找、搜索文件和查找缓冲区 find_files = &quot;&lt;leader&gt;ff&quot;, live_grep = &quot;&lt;leader&gt;fg&quot;, search_cursor = &quot;&lt;leader&gt;fc&quot;, find_buffer = &quot;&lt;leader&gt;fb&quot;, -- Use the to close telescope window. &lt;C-c&gt; is the default setting, can't edit it here. -- close_telescope = &quot;&lt;C-c&gt;&quot;, -- View other usage of the plugin: https://github.com/sindrets/diffview.nvim -- Use the shortcut to open 'git diff'. diff_open = &quot;&lt;leader&gt;df&quot;, -- Use the shortcut to close 'git diff'. diff_close = &quot;&lt;leader&gt;dc&quot;, -- View other usage of the plugin: https://github.com/mrjones2014/smart-splits.nvim -- 使用快捷键&lt;control + alt + hjkl&gt;调整窗口大小 resize_left = &quot;&lt;C-A-h&gt;&quot;, resize_down = &quot;&lt;C-A-j&gt;&quot;, resize_up = &quot;&lt;C-A-k&gt;&quot;, resize_right = &quot;&lt;C-A-l&gt;&quot;, -- View other usage of the plugin: https://github.com/neovim/nvim-lspconfig -- Goto goto_definition = &quot;gd&quot;, goto_references = &quot;gr&quot;, goto_declaration = &quot;gD&quot;, goto_impl = &quot;gi&quot;, -- goto_back = &quot;&lt;C-o&gt;&quot;, -- 使用快捷方式重命名代码符号 lsp_rename = &quot;&lt;leader&gt;re&quot;, -- 使用快捷方式格式化代码。 format = &quot;&lt;leader&gt;ft&quot;, }","link":"/2023/07/04/nvim%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E5%BF%98/"},{"title":"使用sigaction实现signal","text":"下面是经过APUE的学习，实现系统调用signal函数的一个demo，以及对signal和sigaction的理解 signal的原型 123__sighandler_t signal (int __sig, __sighandler_t __handler)// signal函数用来在进程中指定当一个信号到达进程后该做什么处理，主要的两种方式有忽略某些信号，(监听到SIGTERM/SIGINT)退出前的打扫工作。// 返回值为上次信号处理时调用的处理函数 sigaction的原型 12345int sigaction (int __sig, const struct sigaction *__restrict __act, struct sigaction *__restrict __oact) // 参数：// __sig 要捕捉的信号// __act 信号的处理参数// __oact 保存信号上次安装时的处理参数(备份的作用) 因为signal是系统调用，不属于POSIX，所以在可移植性上signal并不可靠。使用POSIX的sigaction实现signal可以提高程序的可移植性 不难看出看出，只需要对sigaction函数的参数做些许设置，就可以很容易的实现signal 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;myinclude.h&gt;#include &lt;signal.h&gt;__sighandler_t _signal(int signo, __sighandler_t func){ struct sigaction nact, oact; nact.sa_handler = func; sigemptyset(&amp;nact.sa_mask); // 将信号集设置为空，以免屏蔽掉其他信号 if(SIGALRM == signo) {#ifdef SA_INTERRUPT nact.sa_flags = SA_INTERRUPT;#endif } else { nact.sa_flags = SA_RESTART; } sigaction(signo, &amp;nact, &amp;oact); return oact.sa_handler; }void handler(int signo){ printf(&quot;catch the signal: %s\\n&quot;, strsignal(signo));}int main(){ _signal(SIGINT, handler); while(1); return 0;}","link":"/2023/07/05/%E4%BD%BF%E7%94%A8sigaction%E5%AE%9E%E7%8E%B0signal/"},{"title":"posix信号量与system V信号量","text":"在APUE中，对于systemV和posix下的信号量均作了详细的介绍 在这里，为了进一步体会两种标准下的信号量的差异，我分别用两种信号量实现了读写的进程同步问题 posix： 123456789101112131415161718192021222324252627282930313233343536373839404142// 读#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;semaphore.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main(){ sem_t *r_sem, *w_sem; if((r_sem = sem_open(&quot;r_sem&quot;, O_CREAT, 0600, 0)) &lt; 0) { perror(&quot;sem_open&quot;); exit(-1); } if((w_sem = sem_open(&quot;w_sem&quot;, O_CREAT, 0600, 1)) &lt; 0) { perror(&quot;sem_open&quot;); exit(-1); } while(1) { if(sem_wait(r_sem) &lt; 0) { perror(&quot;sem_wait&quot;); exit(-1); } sleep(2); printf(&quot;read!\\n&quot;); if(sem_post(w_sem) &lt; 0) { perror(&quot;sem_post&quot;); exit(-1); } } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142// 写#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;semaphore.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main(){ sem_t *r_sem, *w_sem; if((r_sem = sem_open(&quot;r_sem&quot;, O_CREAT, 0600, 0)) &lt; 0) { perror(&quot;sem_open&quot;); exit(-1); } if((w_sem = sem_open(&quot;w_sem&quot;, O_CREAT, 0600, 1)) &lt; 0) { perror(&quot;sem_open&quot;); exit(-1); } while(1) { if(sem_wait(w_sem) &lt; 0) { perror(&quot;sem_wait&quot;); exit(-1); } sleep(2); printf(&quot;write!\\n&quot;); if(sem_post(r_sem) &lt; 0) { perror(&quot;sem_post&quot;); exit(-1); } } return 0;} system V 123456789101112131415161718192021222324252627282930313233343536373839404142// 读#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;int main(){ struct sembuf p_sb, v_sb; int read_semid = semget(128, 1, 0664 | IPC_CREAT); int write_semid = semget(129, 1, 0664 | IPC_CREAT); semctl(read_semid, 0, SETVAL, 0); semctl(write_semid, 0, SETVAL, 1); p_sb.sem_op = -1; p_sb.sem_num = 0; p_sb.sem_flg = 0; v_sb.sem_op = 1; v_sb.sem_num = 0; v_sb.sem_flg = 0; while(1) { if(semop(read_semid, &amp;p_sb, 1) &lt; 0) { perror(&quot;semop&quot;); } sleep(1); printf(&quot;read!\\n&quot;); if(semop(write_semid, &amp;v_sb, 1) &lt; 0) { perror(&quot;semop&quot;); } } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839// 写#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;int main(){ struct sembuf p_sb, v_sb; int read_semid = semget(128, 1, 0664 | IPC_CREAT); int write_semid = semget(129, 1, 0664 | IPC_CREAT); p_sb.sem_op = -1; p_sb.sem_num = 0; p_sb.sem_flg = 0; v_sb.sem_op = 1; v_sb.sem_num = 0; v_sb.sem_flg = 0; while(1) { if(semop(write_semid, &amp;p_sb, 1) &lt; 0) { perror(&quot;semop&quot;); } sleep(2); printf(&quot;write!\\n&quot;); if(semop(read_semid, &amp;v_sb, 1) &lt; 0) { perror(&quot;semop&quot;); } } return 0;} 我们可以看到，posix信号量的优势在于使用简单，并且使用内存映射，并不通过内核，所以速度很快。但posix信号量的缺点也很明显，这种信号量的用法单一，不如systemV信号量灵活","link":"/2023/07/06/posix%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8Esystem-V%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"title":"笔试题分享1","text":"单选题： 以读写方式打开一个已存在的标准I/O流文件且不清除已有内容时应指定哪个mode参数( )[A] r [B] r+ [C] w+ [D] a+ 2 操作系统提供给用户程序的一组”特殊”接口，用户程序可以通过这组”特殊”接口来获得操作系统内核提供的特殊服务。这组”特殊”接口被称为( )A 函数 B api C 方法 D系统调用 以下哪种方法无法查看进程的信息 ( )[A] ps [B] 查看/proc目录 [C] kill [D] top fork()的返回值不可能是( )[A] -1 [B] 0 [C] 1 [D] 大于10000的正整数 下列哪个是不带缓存的( )[A] stdin [B] stdout [C] stderr [D] 都不是 下列哪个函数无法传递进程结束时的状态 ( )[A]close [B] exit [C] _exit [D] return 以下哪种用法可以等待接收进程号为pid的子进程的退出状态 ( ) [A] waitpid(pid, &amp;status, 0) [B] waitpid(pid, &amp;status, WNOHANG) [C] waitpid(-1, &amp;status, 0) [D] waitpid(-1, &amp;status, WNOHANG) 文件权限0662另外一种表示方法是 ( )[A] rw-rw-rwx [B] r–r–rw- [C] rw-rw–w- [D] rw-rw-r– 下列对无名管道描述错误的是 ( )[A] 半双工的通信模式[B] 有固定的读端和写端[C] 可以使用lseek函数[D] 只存在于内存中 10.下列对于有名管道描述错误的是 ( )[A] 可以用于互不相关的进程间[B] 通过路径名来打开有名管道[C] 在文件系统中可见[D] 管道内容保存在磁盘上 下列不属于用户进程对信号的响应方式的是 ()[A] 忽略信号 [B] 保存信号 [C] 捕捉信号 [D] 按缺省方式处理 不能被用户进程屏蔽的信号是 ( )[A] SIGINT [B] SIGKILL [C] SIGQUIT [D] SIGILL 默认情况下，不会终止进程的信号是 ( )[A] SIGINT [B] SIGKILL [C] SIGALRM [D] SIGCHLD 14 命令（）可以显示进程的父进程号A ps aux B ps -l C ps -t D 以上都不可以 15 创建线程使用的api是（）A pthread_cancel B pthread_join C pthread_exit D pthread_create 答案：D D C C C A A C C D B B D B D 判断题1.每个进程的进程号和该进程的父进程的进程号在该进程执行期间不会改变 ( )2.要想让父、子进程执行不同的代码段，唯一的办法是调用exec （）3.宏观上看，子进程被创建后从fork()的下一条语句开始执行 ( )4.子进程的进程号等于父进程的进程号加1 ( )5.执行_exit()函数时不会清理IO缓冲 ( )6.exec函数族可以创建一个新的进程来执行指定的程序 ( )7.wait函数无法接收子进程退出的状态 ( )8.无名管道只能用于有亲缘关系的进程 ( )9.对命名管道的读写严格遵循先进先出的规则 ( )10.信号既可以发给前台进程也可以发给后台进程 ( )11.可以用signal()向指定的进程发信号 （ ）12.子进程不会共享父进程在fork前打开的文件描述符 ( )13.消息队列可以按照消息类型读取消息 ( )14.消息队列的读写只能采用阻塞的方式 ( )15.共享内存是一种最为高效的进程间通信方式 ( ) 答案：F F T F T F F T T T F F T F T 不定选择题 以下对静态库和动态库描述正确的有（）A 二者的代码被载入的时刻不同B 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库，因此体积较大C 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在，因此代码体积较小D 使用gcc -static做编译的时候，会使用静态库做静态链接 以下对进程、程序、线程描述正确的有（）A 程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念B 进程是一个动态的概念，它是程序执行的过程，包括创建、调度和消亡C 进程是一个独立的可调度的任务D 同一进程中的线程不能方便的共享数据 以下描述正确的有（）A 在终端上按”ctrl+&quot;会产生SIGINT信号B 子进程结束时，会向父进程发送SIGCHLD信号C alarm()系统函数可以实现向别的进程发送14号信号D 不带参数的kill命令发送的是15号信号 4.程序代码如下 int main(){ pid_t pid1,pid2; if((pid1=fork()) == 0) //child 1 { sleep(3); printf(“info1 from child process_1\\n”); exit(0); printf(“info2 from child process_1\\n”); } else { if((pid2=fork()) == 0) //child 2 { sleep(1); printf(“info1 from child process_2\\n”); exit(0); } else //parent { wait(NULL); wait(NULL); printf(“info1 from parent process\\n”); printf(“info2 from parent process”); _exit(0); } }}程序运行后，将会出现何种结果（）Ainfo1 from child process_2info1 from child process_1info1 from parent process Binfo1 from child process_1info1 from child process_2info1 from parent process Cinfo1 from child process_2info1 from child process_1info1 from parent processinfo2 from parent process Dinfo1 from child process_2info1 from child process_1info1 from parent processinfo2 from child process_1 以下哪些是Linux的进程间的通信机制（）A 无名管道(pipe) B 有名管道(fifo) C 信号(signal) D 共享内存(share memory)F 消息队列(message queue) G 信号灯(semaphore) H 套接字(socket) I 全局变量 以下创建守护进程的步骤中，描述正确的是（）A 创建子进程，父进程退出，目的之一是为创建新会话创造条件B 在子进程中创建新会话，其目的是为了让守护进程与原来的会话、控制终端等彻底脱离关系，不受其影响C 应当使用chdir()函数将当前目录切换为守护进程的工作根目录D 使用umask函数重设文件权限掩码，其目的是使得守护进程创建新文件的时候，不受其原来父进程的影响E 关闭文件描述符，其目的之一是使得守护进程不能向屏幕输出内容，以免给用户造成迷惑 以下关于进程状态及切换，描述正确的有（）A 处于运行态（R态）的进程被OS调度运行，从而使用CPU进行运行。因运行时间片用完，而被OS调度不再使用CPU，但仍然处于运行态B 使用CPU的进程可能因为需要的资源得不到满足，而放弃CPU，进入到等待态（S态）C 等待态（S态）的进程，因需要的资源得到满足，将进入R态D 拥有CPU的进程，可能因为接收到SIGSTOP信号而进入到停止态（T态）E 进程对应的程序运行结束后，但尚未被其父进程wait到结束状态，该进程将进入僵尸态（Z态 ） 答案：ABCD ABC BD A ABCDEFGH ABCDE ABCDE 编程题： 使用fork创建子进程 使用pipe创建无名管道 父进程接受用户从键盘输入的若干行英文字符串（每行输入不超过1024个字符），并将这些字符串原封不动的转发给无名管道（使用write） 子进程从无名管道中接收父进程转发来的字符串（使用read），实现小写字母到大写字母的转换后，输出到屏幕（大小写转换可以使用C库函数toupper） 当用户结束键盘输入后（即：用户按下ctrl+D），父进程应当立即关闭无名管道写端；子进程在父进程关闭无名管道后，应当立即关闭无名管道读端，然后以退出值0结束自己；父进程应当等待子进程结束后，打印子进程的退出值。","link":"/2023/07/07/%E7%AC%94%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB1/"},{"title":"tcp文件服务器","text":"本文将介绍简单基于tcp的文件服务器需求编写 tcp 文件服务器和客户端。客户端可以上传和下载文件 客户端功能如下： 支持以下命令 help : 显示客户端所有命令和说明 list : 显示服务器端可下载文件列表 get : 下载文件 put : 上传文件 quit : 退出客户端 服务器端功能(单进程)： 解析客户端命令并提供相应服务 流程分析代码实现客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;void printHelp();int downfile(int cfd, char* filename);int upload(int cfd, char *filename);int main(){ int cfd; if ((cfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(&quot;socket&quot;); exit(-1); } struct sockaddr_in seraddr; seraddr.sin_family = AF_INET; seraddr.sin_port = htons(9999); seraddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); int ret = connect(cfd, (struct sockaddr *)&amp;seraddr, sizeof(seraddr)); if (ret == -1) { perror(&quot;connect&quot;); exit(-1); } printf(&quot;connect success\\n&quot;); char buf[1024] = {0}; while (1) { bzero(buf, sizeof(buf)); ret = read(STDIN_FILENO, buf, sizeof(buf)); buf[ret - 1] = 0; printf(&quot;read: %s\\n&quot;, buf); if(ret == -1) { perror(&quot;read&quot;); exit(-1); } if (strcmp(buf, &quot;help&quot;) == 0) { printHelp(); } else if (strncmp(buf, &quot;list&quot;, 4) == 0) { printf(&quot;File List: \\n&quot;); write(cfd, &quot;list&quot;, sizeof(&quot;list&quot;)); ret = read(cfd, buf, sizeof(buf)); write(STDIN_FILENO, buf, ret); } else if (strncmp(buf, &quot;quit&quot;, 4) == 0) { close(cfd); printf(&quot;close connect\\n&quot;); break; } else if (strncmp(buf, &quot;get&quot;, 3) == 0) { char *ptr = buf + 3; while(*(++ptr) == ' '); write(cfd, buf, strlen(buf)); sleep(1); ret = downfile(cfd, ptr); if(ret == 0) { printf(&quot;downfile success\\n&quot;); } } else if (strncmp(buf, &quot;put&quot;, 3) == 0) { char *ptr = buf + 3; while(*(++ptr) == ' '); write(cfd, buf, strlen(buf)); sleep(1); ret = upload(cfd, ptr); if(ret == 0) { printf(&quot;upload success\\n&quot;); } } else { printf(&quot;err\\n&quot;); } } close(cfd); return 0;}void printHelp(){ printf(&quot;help:\\n\\ help :显示客户端所有命令和说明\\n\\ list :显示服务器端可下载文件列表\\n\\ get &lt;file&gt; :下载文件\\n\\ put &lt;file&gt; :上传文件\\n\\ quit :退出客户端\\n&quot;);}int downfile(int cfd, char* filename){ int ret; int filesize; char buf[1024] = {0}; ret = read(cfd, buf, sizeof(buf)); buf[ret] = 0; if(strcmp(buf, &quot;没有这个文件&quot;) == 0) { printf(&quot;没有这个文件\\n&quot;); return -1; } filesize = atoi(buf); printf(&quot;文件大小为 %d\\n&quot;, filesize); int fd = open(filename, O_RDWR | O_CREAT | O_TRUNC, 0664); if(fd == -1) { perror(&quot;open&quot;); return -1; } lseek(fd, 0, SEEK_SET); int sizeCount = 0; while((ret = read(cfd, buf, sizeof(buf))) != 0) { buf[ret] = 0; if(ret == -1) { perror(&quot;read&quot;); return -1; } write(fd, buf, ret); sizeCount += ret; if(sizeCount == filesize) { break; } } close(fd); return 0;}int upload(int cfd, char *filename){ int ret, fd; int filesize; struct stat fstat; char buf[1024] = {0}; ret = stat(filename, &amp;fstat); if(ret == -1) { printf(&quot;没有这个文件\\n&quot;); write(cfd, &quot;没有这个文件&quot;, sizeof(&quot;没有这个文件&quot;)); return -1; } filesize = fstat.st_size; sprintf(buf, &quot;%d&quot;, filesize); write(cfd, buf, strlen(buf) + 1); sleep(1); fd = open(filename, O_RDONLY); if (fd == -1) { perror(&quot;open&quot;); return -1; } while ((ret = read(fd, buf, sizeof(buf))) &gt; 0) // 发送文件 write(cfd, buf, ret); return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int sendfile(int cfd, char *filename);int recvfile(int cfd, char *filename);int getList(int cfd);int main(){ int lfd, cfd; if ((lfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(&quot;socket&quot;); exit(-1); } struct sockaddr_in seraddr; seraddr.sin_family = AF_INET; seraddr.sin_addr.s_addr = INADDR_ANY; seraddr.sin_port = htons(9999); int ret = bind(lfd, (struct sockaddr *)&amp;seraddr, sizeof(seraddr)); if (ret == -1) { perror(&quot;bind&quot;); exit(-1); } ret = listen(lfd, 255); if (ret == -1) { perror(&quot;bind&quot;); exit(-1); } struct sockaddr_in cliaddr; socklen_t clilen = sizeof(cliaddr); cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen); if (cfd == -1) { perror(&quot;accept&quot;); exit(-1); } printf(&quot;the client connect success\\n&quot;); char buf[1024] = {0}; while (1) { bzero(buf, sizeof(buf)); ret = read(cfd, buf, sizeof(buf)); buf[ret] = 0; printf(&quot;recv: %s\\n&quot;, buf); if (ret == -1) { perror(&quot;read&quot;); exit(-1); } printf(&quot;read: %s\\n&quot;, buf); if (ret == 0) { printf(&quot;client quit\\n&quot;); break; } if (strncmp(buf, &quot;get&quot;, 3) == 0) { printf(&quot;get\\n&quot;); char *ptr = buf + 3; while(*(++ptr) == ' '); printf(&quot;file name: %s\\n&quot;, ptr); sendfile(cfd, ptr); } else if (strncmp(buf, &quot;put&quot;, 3) == 0) { char *ptr = buf + 3; while(*(++ptr) == ' '); ret = recvfile(cfd, ptr); if(ret == 0) { printf(&quot;recvfile success\\n&quot;); } } else if (strncmp(buf, &quot;list&quot;, 4) == 0) { getList(cfd); } else { printf(&quot;err&quot;); } } close(lfd); close(cfd); return 0;}int sendfile(int cfd, char *filename){ int ret, filesize, fd; struct stat fstat; char buf[1024] = {0}; ret = stat(filename, &amp;fstat); if(ret == -1) { printf(&quot;没有这个文件\\n&quot;); write(cfd, &quot;没有这个文件&quot;, sizeof(&quot;没有这个文件&quot;)); return -1; } filesize = fstat.st_size; sprintf(buf, &quot;%d&quot;, filesize); sleep(1); write(cfd, buf, strlen(buf) + 1); sleep(1); fd = open(filename, O_RDONLY); if (fd == -1) return -1; while ((ret = read(fd, buf, sizeof(buf))) &gt; 0){ // 发送文件 write(cfd, buf, ret); } close(fd); printf(&quot;send success\\n&quot;); return 0;}int recvfile(int cfd, char *filename){ int ret; int filesize; char buf[1024] = {0}; ret = read(cfd, buf, sizeof(buf)); buf[ret] = 0; if(strcmp(buf, &quot;没有这个文件&quot;) == 0) { printf(&quot;没有这个文件\\n&quot;); return -1; } filesize = atoi(buf); printf(&quot;文件大小为 %d\\n&quot;, filesize); int fd = open(filename, O_RDWR | O_CREAT | O_TRUNC, 0664); if(fd == -1) { perror(&quot;open&quot;); return -1; } lseek(fd, 0, SEEK_SET); int sizeCount = 0; while((ret = read(cfd, buf, sizeof(buf))) &gt; 0) { buf[ret] = 0; int i = write(fd, buf, ret); // printf(&quot;写入 = %d字节\\n&quot;, i); sizeCount += ret; if(sizeCount == filesize) { break; } } close(fd); return 0;}int getList(int cfd){ struct dirent *sdp; DIR* dp = opendir(&quot;./&quot;); int ret; char buf[1024] = {0}; while((sdp = readdir(dp)) != 0) { if (!strcmp(sdp-&gt;d_name, &quot;.&quot;) | !strcmp(sdp-&gt;d_name, &quot;..&quot;)) continue; sprintf(buf, &quot;%s%s\\n&quot;, buf, sdp-&gt;d_name); } write(cfd, buf, strlen(buf)); return 0;} 进阶尝试使用多进程，多线程实现多用户的文件服务器","link":"/2023/07/11/tcp%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"wsl2环境编译32位程序","text":"wsl2环境编译32位程序 在原生的wsl2环境下是无法直接运行32位程序的。所以我们要先安装支持运行32位程序的库 123sudo dpkg --add-architecture i386sudo apt-get updatesudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 使用gcc编译时，使用编译选项-m32,就可以编译出32位的程序了","link":"/2023/07/27/wsl2%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%9132%E4%BD%8D%E7%A8%8B%E5%BA%8F/"},{"title":"Qt 事件处理","text":"Qt中的事件过滤器机制允许对其他对象的事件进行拦截和处理 123使用它的流程是 创建事件过滤器类,继承自QObject,并实现eventFilter()方法。 在其他对象上安装事件过滤器: 1otherObj-&gt;installEventFilter(filter); 当otherObj收到事件时,会调用事件过滤器的eventFilter()方法: 1234567891011121314bool Filter::eventFilter(QObject *watched, QEvent *event) {// 过滤处理return true或false;}/* eventFilter()方法有两个参数:watched: 发送事件的对象,这里是otherObjevent: 事件对象本身方法返回bool值:true - 表示过滤器已经处理了该事件,停止传递事件false - 表示事件可以继续传递给其他过滤器或对象自己的事件处理函数*/ Qt会将事件生成对应的事件对象。所有事件类都继承自QEvent。 事件对象会首先传递给目标对象的event()函数。event()函数会先检查是否有事件过滤器,如果有事件过滤器,就会调用过滤器进行处理。 如果过滤器返回false,或者没有过滤器,event()会根据事件类型调用相应的事件处理函数,如mousePressEvent 如果对象自身没有处理事件,则会向父对象传递。 如果所有对象都没有处理,最终传递给应用对象进行默认处理。","link":"/2023/08/04/Qt-%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"title":"arm汇编实现冒泡排序","text":"最近学习了arm体系架构与接口技术，在学习过程中，使用arm汇编实现了冒泡排序 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。 1234567891011121314151617181920212223242526272829303132333435363738394041// 在该排序算法时，使用了基址变址的方式来访问内存数据// 由于每个数据占4字节，所以将偏移寄存器的偏移量设置为2，也就是乘4 这样寻得的地址为 基址 + i / j * 4,就可以像语言一样访问内存// 可以轻松的访问内存后就可以很快的写出排序算法了// 值得注意的地方是要注意for循环的转跳和自加操作的先后顺序.global _start, _data_data:.word 0x21, 0x11, 0x16, 0x11, 0x22, 0x33, 0x15_start: ldr r0, =_data // 基址 mov r1, #0 // i mov r2, #0 // j mov r3, #0 // j + 1A: mov r2, #0 // j == 0 mov r3, #0B: add r3, r2, #1 // r2 = j, r3 = j + 1 ldr r5, [r0, r2, LSL #2] // (取i，j上的数据)取 r0 + r1 * 4处的数据 ldr r6, [r0, r3, LSL #2] cmp r5, r6 // 比较 strgt r6, [r0, r2, LSL #2] // 交换 strgt r5, [r0, r3, LSL #2] mov r7, #7 // 数组最大下标 sub r7, r7, r1 // j &lt; len - i - 1 sub r7, r7, #1 add r2 , r2, #1 // j ++ cmp r2, r7blt B // B 循环跳转 mov r7, #7 sub r7, r7, #1 // i &lt; len - 1 add r1, r1, #1 // i++ cmp r1, r7 blt A // A 循环跳转 nop nop","link":"/2023/08/16/arm%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"c&#x2F;cpp","slug":"c-cpp","link":"/tags/c-cpp/"},{"name":"wsl","slug":"wsl","link":"/tags/wsl/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"apue","slug":"apue","link":"/tags/apue/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"Qt","slug":"Qt","link":"/tags/Qt/"},{"name":"asm","slug":"asm","link":"/tags/asm/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"经验分享","slug":"经验分享","link":"/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"学习感悟","slug":"学习感悟","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"},{"name":"笔试题","slug":"笔试题","link":"/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"},{"name":"学习记录","slug":"学习记录","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"pages":[]}