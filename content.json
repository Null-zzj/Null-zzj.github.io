{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/29/hello-world/"},{"title":"vscode &amp; wsl2 实现c&#x2F;cpp的多文件编译调试","text":"本篇文章将介绍wsl2环境下 vscode的多文件编译 vscode和wsl2的安装与下载就不再过多的赘述 step1: 安装vscode插件 12C/C++ Extension Packcmake step2：在linux安装cmake， make 使用cmake是因为cmake对于多文件编译比较方便 debian系linux可以使用以下命令一键安装 1sudo apt install cmake make gcc g++ gbd 在这里，环境方面就准备的差不多了 接下来配置vscode中最令人头疼的tasks.json 与 launch.json 调试时，在当前文件所在的目录下新建一个bulid文件，以免生成过多的cmake的文件 tasks.json 1234567891011121314151617181920212223242526272829303132333435{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;options&quot;: { &quot;cwd&quot;: &quot;${fileDirname}/build&quot; }, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;cmake&quot;, &quot;command&quot;: &quot;cmake&quot;, &quot;args&quot;: [ &quot;..&quot; ] }, { &quot;label&quot;: &quot;make&quot;, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }, &quot;command&quot;: &quot;make&quot;, &quot;args&quot;: [] }, { &quot;label&quot;: &quot;Build&quot;, &quot;dependsOrder&quot;: &quot;sequence&quot;, &quot;dependsOn&quot;: [ &quot;cmake&quot;, &quot;make&quot; ] } ],} launch.json 123456789101112131415161718192021222324252627282930313233343536{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) hqyj&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/bulid/${fileBasenameNoExtension}&quot;, // 这里是可执行文件路径，可以根据自己的需求更改 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;/usr/bin&quot;, &quot;environment&quot;:[], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;Build&quot; } ]} 配置完成后，就可以开始愉快的编码啦","link":"/2023/07/03/vscode-wsl2-%E5%AE%9E%E7%8E%B0c-cpp%E7%9A%84%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/"},{"title":"nvim快捷键备忘","text":"return { – The default ‘‘ is the space. leader = “ “, -- 键切换/跳转窗口 jump_left_window = &quot;&lt;C-h&gt;&quot;, jump_right_window = &quot;&lt;C-l&gt;&quot;, jump_up_window = &quot;&lt;C-k&gt;&quot;, jump_down_window = &quot;&lt;C-j&gt;&quot;, -- View other usage of the plugin: https://github.com/akinsho/bufferline.nvim -- 选择缓冲区选项卡 pick_tab = &quot;&lt;leader&gt;b&quot;, -- View other usage of the plugin: https://github.com/nvim-neo-tree/neo-tree.nvim -- 打开或关闭文件资源管理器。 file_explorer = &quot;&lt;F9&gt;&quot;, -- 打开或关闭浮动窗口上的git status。 git_status = &quot;&lt;F8&gt;&quot;, -- View other usage of the plugin: https://github.com/stevearc/aerial.nvim -- 打开或关闭大纲，它需要调用lsp服务器 outline = &quot;&lt;F7&gt;&quot;, -- View other usage of the plugin: https://github.com/akinsho/toggleterm.nvim -- 打开或关闭终端 terminal_float = &quot;&lt;A-u&gt;&quot;, -- open terminal in a float window terminal_bottom = &quot;&lt;A-b&gt;&quot;, -- open terminal at the bottom -- View other usage of the plugin: https://github.com/Shatur/neovim-session-manager -- 切换会话 switch_session = &quot;&lt;leader&gt;ss&quot;, -- View other usage of the plugin: https://github.com/nvim-telescope/telescope.nvim -- 查找、搜索文件和查找缓冲区 find_files = &quot;&lt;leader&gt;ff&quot;, live_grep = &quot;&lt;leader&gt;fg&quot;, search_cursor = &quot;&lt;leader&gt;fc&quot;, find_buffer = &quot;&lt;leader&gt;fb&quot;, -- Use the to close telescope window. &lt;C-c&gt; is the default setting, can't edit it here. -- close_telescope = &quot;&lt;C-c&gt;&quot;, -- View other usage of the plugin: https://github.com/sindrets/diffview.nvim -- Use the shortcut to open 'git diff'. diff_open = &quot;&lt;leader&gt;df&quot;, -- Use the shortcut to close 'git diff'. diff_close = &quot;&lt;leader&gt;dc&quot;, -- View other usage of the plugin: https://github.com/mrjones2014/smart-splits.nvim -- 使用快捷键&lt;control + alt + hjkl&gt;调整窗口大小 resize_left = &quot;&lt;C-A-h&gt;&quot;, resize_down = &quot;&lt;C-A-j&gt;&quot;, resize_up = &quot;&lt;C-A-k&gt;&quot;, resize_right = &quot;&lt;C-A-l&gt;&quot;, -- View other usage of the plugin: https://github.com/neovim/nvim-lspconfig -- Goto goto_definition = &quot;gd&quot;, goto_references = &quot;gr&quot;, goto_declaration = &quot;gD&quot;, goto_impl = &quot;gi&quot;, -- goto_back = &quot;&lt;C-o&gt;&quot;, -- 使用快捷方式重命名代码符号 lsp_rename = &quot;&lt;leader&gt;re&quot;, -- 使用快捷方式格式化代码。 format = &quot;&lt;leader&gt;ft&quot;, }","link":"/2023/07/04/nvim%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E5%BF%98/"},{"title":"使用sigaction实现signal","text":"下面是经过APUE的学习，实现系统调用signal函数的一个demo，以及对signal和sigaction的理解 signal的原型 123__sighandler_t signal (int __sig, __sighandler_t __handler)// signal函数用来在进程中指定当一个信号到达进程后该做什么处理，主要的两种方式有忽略某些信号，(监听到SIGTERM/SIGINT)退出前的打扫工作。// 返回值为上次信号处理时调用的处理函数 sigaction的原型 12345int sigaction (int __sig, const struct sigaction *__restrict __act, struct sigaction *__restrict __oact) // 参数：// __sig 要捕捉的信号// __act 信号的处理参数// __oact 保存信号上次安装时的处理参数(备份的作用) 因为signal是系统调用，不属于POSIX，所以在可移植性上signal并不可靠。使用POSIX的sigaction实现signal可以提高程序的可移植性 不难看出看出，只需要对sigaction函数的参数做些许设置，就可以很容易的实现signal 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;myinclude.h&gt;#include &lt;signal.h&gt;__sighandler_t _signal(int signo, __sighandler_t func){ struct sigaction nact, oact; nact.sa_handler = func; sigemptyset(&amp;nact.sa_mask); // 将信号集设置为空，以免屏蔽掉其他信号 if(SIGALRM == signo) {#ifdef SA_INTERRUPT nact.sa_flags = SA_INTERRUPT;#endif } else { nact.sa_flags = SA_RESTART; } sigaction(signo, &amp;nact, &amp;oact); return oact.sa_handler; }void handler(int signo){ printf(&quot;catch the signal: %s\\n&quot;, strsignal(signo));}int main(){ _signal(SIGINT, handler); while(1); return 0;}","link":"/2023/07/05/%E4%BD%BF%E7%94%A8sigaction%E5%AE%9E%E7%8E%B0signal/"},{"title":"posix信号量与system V信号量","text":"在APUE中，对于systemV和posix下的信号量均作了详细的介绍 在这里，为了进一步体会两种标准下的信号量的差异，我分别用两种信号量实现了读写的进程同步问题 posix： 123456789101112131415161718192021222324252627282930313233343536373839404142// 读#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;semaphore.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main(){ sem_t *r_sem, *w_sem; if((r_sem = sem_open(&quot;r_sem&quot;, O_CREAT, 0600, 0)) &lt; 0) { perror(&quot;sem_open&quot;); exit(-1); } if((w_sem = sem_open(&quot;w_sem&quot;, O_CREAT, 0600, 1)) &lt; 0) { perror(&quot;sem_open&quot;); exit(-1); } while(1) { if(sem_wait(r_sem) &lt; 0) { perror(&quot;sem_wait&quot;); exit(-1); } sleep(2); printf(&quot;read!\\n&quot;); if(sem_post(w_sem) &lt; 0) { perror(&quot;sem_post&quot;); exit(-1); } } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142// 写#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;semaphore.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main(){ sem_t *r_sem, *w_sem; if((r_sem = sem_open(&quot;r_sem&quot;, O_CREAT, 0600, 0)) &lt; 0) { perror(&quot;sem_open&quot;); exit(-1); } if((w_sem = sem_open(&quot;w_sem&quot;, O_CREAT, 0600, 1)) &lt; 0) { perror(&quot;sem_open&quot;); exit(-1); } while(1) { if(sem_wait(w_sem) &lt; 0) { perror(&quot;sem_wait&quot;); exit(-1); } sleep(2); printf(&quot;write!\\n&quot;); if(sem_post(r_sem) &lt; 0) { perror(&quot;sem_post&quot;); exit(-1); } } return 0;} system V 123456789101112131415161718192021222324252627282930313233343536373839404142// 读#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;int main(){ struct sembuf p_sb, v_sb; int read_semid = semget(128, 1, 0664 | IPC_CREAT); int write_semid = semget(129, 1, 0664 | IPC_CREAT); semctl(read_semid, 0, SETVAL, 0); semctl(write_semid, 0, SETVAL, 1); p_sb.sem_op = -1; p_sb.sem_num = 0; p_sb.sem_flg = 0; v_sb.sem_op = 1; v_sb.sem_num = 0; v_sb.sem_flg = 0; while(1) { if(semop(read_semid, &amp;p_sb, 1) &lt; 0) { perror(&quot;semop&quot;); } sleep(1); printf(&quot;read!\\n&quot;); if(semop(write_semid, &amp;v_sb, 1) &lt; 0) { perror(&quot;semop&quot;); } } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839// 写#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;int main(){ struct sembuf p_sb, v_sb; int read_semid = semget(128, 1, 0664 | IPC_CREAT); int write_semid = semget(129, 1, 0664 | IPC_CREAT); p_sb.sem_op = -1; p_sb.sem_num = 0; p_sb.sem_flg = 0; v_sb.sem_op = 1; v_sb.sem_num = 0; v_sb.sem_flg = 0; while(1) { if(semop(write_semid, &amp;p_sb, 1) &lt; 0) { perror(&quot;semop&quot;); } sleep(2); printf(&quot;write!\\n&quot;); if(semop(read_semid, &amp;v_sb, 1) &lt; 0) { perror(&quot;semop&quot;); } } return 0;} 我们可以看到，posix信号量的优势在于使用简单，并且使用内存映射，并不通过内核，所以速度很快。但posix信号量的缺点也很明显，这种信号量的用法单一，不如systemV信号量灵活","link":"/2023/07/06/posix%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8Esystem-V%E4%BF%A1%E5%8F%B7%E9%87%8F/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"c&#x2F;cpp","slug":"c-cpp","link":"/tags/c-cpp/"},{"name":"wsl","slug":"wsl","link":"/tags/wsl/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"apue","slug":"apue","link":"/tags/apue/"}],"categories":[{"name":"经验分享","slug":"经验分享","link":"/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"学习感悟","slug":"学习感悟","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"}],"pages":[]}